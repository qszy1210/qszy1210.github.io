<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <author>
    <name>张青松</name>
  </author>
  <generator uri="https://hexo.io/">Hexo</generator>
  <icon>https://qs12.cn/favicon.ico</icon>
  <id>https://qs12.cn/</id>
  <link href="https://qs12.cn/" rel="alternate"/>
  <link href="https://qs12.cn/atom.xml" rel="self"/>
  <rights>All rights reserved 2026, 张青松</rights>
  <title>青松的小站</title>
  <updated>2025-07-11T06:34:18.217Z</updated>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="css ruanyifeng 文摘" scheme="https://qs12.cn/tags/css-ruanyifeng-%E6%96%87%E6%91%98/"/>
    <content>
      <![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2022/11/weekly-issue-229.html">科技爱好者229</a> 中介绍了 <a href="https://austingil.com/html-capture-attribute/"><em>input元素的capture属性</em></a></p><p>所以去看了一下;</p><h3 id="主要说明是-input-元素可以用两个-capture-属性-具体的值有-user-和-environment"><a href="#主要说明是-input-元素可以用两个-capture-属性-具体的值有-user-和-environment" class="headerlink" title="主要说明是 input 元素可以用两个 capture 属性, 具体的值有 user 和 environment"></a>主要说明是 <code>input</code> 元素可以用两个 <code>capture</code> 属性, 具体的值有 <code>user</code> 和 <code>environment</code></h3><ol><li><code>user</code>  会采用前置摄像头 or 麦克风</li><li><code>environment</code> 会采用后置摄像头 or 麦克风</li></ol><p>摘录一下他们的文档片段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;environment&quot;</span>&gt;</span>Capture environment:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;environment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">capture</span>=<span class="string">&quot;environment&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">accept</span>=<span class="string">&quot;video/*&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;user&quot;</span>&gt;</span>Capture user:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">capture</span>=<span class="string">&quot;user&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://qs12.cn/2022/11/10/input%E5%85%83%E7%B4%A0%E7%9A%84capture%E5%B1%9E%E6%80%A7/</id>
    <link href="https://qs12.cn/2022/11/10/input%E5%85%83%E7%B4%A0%E7%9A%84capture%E5%B1%9E%E6%80%A7/"/>
    <published>2022-11-10T12:31:43.000Z</published>
    <summary>
      <![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2022/11/weekly-issue-229.html">科技爱好者229</a> 中介绍了 <a href="https://austingil.com/html-capture-attribute/"><em>input元素的capture属性</em></a></p>
<p>所以去看了一下;</p>
<h3 id="主要说明是-input-元素可以用两个-capture-属性-具体的值有-user-和-environment"><a href="#主要说明是-input-元素可以用两个-capture-属性-具体的值有-user-和-environment" class="headerlink" title="主要说明是 input 元素可以用两个 capture 属性, 具体的值有 user 和 environment"></a>主要说明是 <code>input</code> 元素可以用两个 <code>capture</code> 属性, 具体的值有 <code>user</code> 和 <code>environment</code></h3><ol>
<li><code>user</code>  会采用前置摄像头 or 麦克风</li>
<li><code>environment</code> 会采用后置摄像头 or 麦克风</li>
</ol>
<p>摘录一下他们的文档片段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="li]]>
    </summary>
    <title>input元素的capture属性</title>
    <updated>2025-07-11T06:34:18.217Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <content>
      <![CDATA[<h2 id="通过命令行安装你的脚手架"><a href="#通过命令行安装你的脚手架" class="headerlink" title="通过命令行安装你的脚手架"></a>通过命令行安装你的脚手架</h2><h5 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h5><p>我们知道 <code>vue-cli</code> <code>create-react-app</code> 等都可以根据你输入的参数进行快速脚手架的搭建.<br>那问题来了, 我们怎么构建自己的脚手架呢?</p><h5 id="分析与思路"><a href="#分析与思路" class="headerlink" title="分析与思路"></a>分析与思路</h5><ol><li>我们可以确定这个命令基本上是一个全局命令(或者说就是一个命令行)</li><li>依赖于 npm (node) 进行执行与安装, 有进一步了解<code>shell</code> 的应该想到要有头标志</li><li>接收参数, 应该是 <code>shell</code> 相关的东西</li><li>脚手架代码, 不管何种形式, 应该是有类似模板项目之类的文件存在. (这个可以从网站下载, 或者直接放在我们的<code>npm</code>中进行拷贝)</li><li>可能的一些其他处理, 比如 <code>npm install</code> 自动安装, 自动执行等(我目前想到的)</li></ol><h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><h6 id="一个非常简单的-demo"><a href="#一个非常简单的-demo" class="headerlink" title="一个非常简单的 demo"></a>一个非常简单的 demo</h6><ol><li><p>初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建自己的项目</span></span><br><span class="line">mkdir my-cli &amp;&amp; cd $_ ##  创建并进入文件夹</span><br><span class="line">npm init -y ## 快速新建自己的 npm 项目</span><br></pre></td></tr></table></figure></li><li><p>模仿 vue-cli，让我们来看一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们去 /usr/local/bin 文件夹下</span></span><br><span class="line">ll vue  ## 如果 ll 不行的话, 尝试执行 `ls -alF` 吧</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现类似的</span></span><br><span class="line">vue -&gt; ../lib/node_modules/@vue/cli/bin/vue.js</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所以这个可执行文件一个是一个 js 文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们进去看一下</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vue 文件内容</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env node</span></span><br><span class="line">// Check node version before requiring/doing anything else</span><br><span class="line">// The user may be on a very old node version</span><br><span class="line"></span><br><span class="line">const &#123; chalk, semver &#125; = require(&#x27;@vue/cli-shared-utils&#x27;)</span><br><span class="line">const requiredVersion = require(&#x27;../package.json&#x27;).engines.node</span><br><span class="line">const leven = require(&#x27;leven&#x27;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>创建自己的<br>通过以上内容, 我们大体得知就是依赖本地的 node 环境去执行这个 js 文件而已.<br>node 是一个服务器语言, 可以操作文件系统, 我们大体知道了后. 尝试创建一下自己</p><p>我尝试复制 模板文件内容 到当前的文件夹</p><p>新建一个<code>文件</code>, 名字叫 <code>my-cli</code><br>新建一个 <code>文件夹</code>, 名字 <code>template</code></p><p>目录结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-template</span><br><span class="line">|- index.js</span><br><span class="line">-my-cli</span><br></pre></td></tr></table></figure><p>my-cli 文件的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env node</span></span><br><span class="line">console.log(&#x27;我自己的脚手架项目&#x27;)</span><br></pre></td></tr></table></figure><p>复制功能: (我们搜索查一下, 我采用执行 linux 的命令, 搜索一大堆, 比如 <a href="https://itbilu.com/nodejs/core/41cswxaTx.html">node复制文件</a> )</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var child_process = require(&#x27;child_process&#x27;);</span><br><span class="line"></span><br><span class="line">function copyDir(src, dist) &#123;</span><br><span class="line">  child_process.spawn(&#x27;cp&#x27;, [&#x27;-r&#x27;, src, dist]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copyDir(&#x27;./template&#x27;, &#x27;./project&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>试着执行一下<br>因为上边用到了 <code>child_process</code> 包, 所以我们安装一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install child_process -S</span><br></pre></td></tr></table></figure><p>然后执行以下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可能需要弄一个全局链接, 我们这里先不做, 执行执行一下</span></span><br><span class="line">./my-cli</span><br><span class="line">zsh: permission denied: ./my-cli #提示这个错误, 增加一下执行权限</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加一下执行权限</span></span><br><span class="line">chmod a+x ./my-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续执行</span></span><br><span class="line">./my-cli</span><br></pre></td></tr></table></figure><p>执行成功的话, 就会出现一个根据模板文件夹复制的 projet 文件夹了</p><h5 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h5><p>增加接收参数</p><p>需要用到的包为 <code>commander</code> , 我怎么知道的呢, 搜索一下就可以 ^_^</p><p><code>commander</code> 的 <a href="https://github.com/tj/commander.js">github地址</a></p><p>看到 说明文档中介绍的, 我们直接按照 <a href="https://github.com/tj/commander.js/blob/master/examples/defaultCommand.js">example</a> 中的进行处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的稍微修改的版本</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Command</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> <span class="title class_">Command</span>();</span><br><span class="line">program.<span class="title function_">version</span>(<span class="string">&#x27;0.0.1&#x27;</span>) <span class="comment">//声明一下版本, 通过 -V 来获取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;create &lt;name&gt;&#x27;</span>)</span><br><span class="line">  .<span class="title function_">description</span>(<span class="string">&#x27;create your project&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这里处理你要的东西</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;build&#x27;</span>, name);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h6 id="一些基本功能-我们就暂时列2个"><a href="#一些基本功能-我们就暂时列2个" class="headerlink" title="一些基本功能, 我们就暂时列2个"></a>一些基本功能, 我们就暂时列2个</h6><ol><li><p>打印脚手架的版本<br>上边的直接进行执行 <code>./my-cli -V</code> 即可</p></li><li><p>接收包的名字<br>根据 name 进行处理, 我们可以在我们的模板中定义一个名字用于替换<br>我新建了一个特殊符号 <code>&lt;%=name&gt;</code> 进行替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是模板文件的具体内容, 我的名字是 &lt;%=name&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是用 node 中的 file 包进行数据处理</span></span><br><span class="line"><span class="comment">// 需要安装 file 和 path 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">replaceFileContent</span>(<span class="params">filePath, srcContent, targetContent</span>) &#123;</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(filePath), <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> result = data.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(srcContent, <span class="string">&#x27;g&#x27;</span>), targetContent);</span><br><span class="line"></span><br><span class="line">      fs.<span class="title function_">writeFile</span>(path.<span class="title function_">resolve</span>(filePath), result, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="代码与思考"><a href="#代码与思考" class="headerlink" title="代码与思考"></a>代码与思考</h5><p>整体的思路其实并不是很难, 主要就是文件的处理与替换, 主要包含一些脚本的知识.</p><p>代码位置: <a href="https://github.com/qszy1210/slog/tree/master/codes/my-cli">my-cli</a></p>]]>
    </content>
    <id>https://qs12.cn/2021/01/04/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%89%E8%A3%85%E4%BD%A0%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <link href="https://qs12.cn/2021/01/04/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%89%E8%A3%85%E4%BD%A0%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <published>2021-01-04T08:54:27.000Z</published>
    <summary>
      <![CDATA[<h2 id="通过命令行安装你的脚手架"><a href="#通过命令行安装你的脚手架" class="headerlink" title="通过命令行安装你的脚手架"></a>通过命令行安装你的脚手架</h2><h5 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h5><p>我们知道 <code>vue-cli</code> <code>create-react-app</code> 等都可以根据你输入的参数进行快速脚手架的搭建.<br>那问题来了, 我们怎么构建自己的脚手架呢?</p>
<h5 id="分析与思路"><a href="#分析与思路" class="headerlink" title="分析与思路"></a>分析与思路</h5><ol>
<li>我们可以确定这个命令基本上是一个全局命令(或者说就是一个命令行)</li>
<li>依赖于 npm (node) 进行执行与安装, 有进一步了解<code>shell</code> 的应该想到要有头标志</li>
<li>接收参数, 应该是 <code>shell</code> 相关的东西</li>
<li>脚手架代码, 不管何种形式, 应该是有类似模板项目之类的文件存在. (这个可以从网站下载, 或者直接放在我们的<code>npm</code>中进行拷贝)</li>
<li>可能的一些其他处理, 比如 <code>npm install</code> 自动安装, 自动执行等(我目前想到的)</li>
</ol>
<h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><h6 id="一个非常简单的-demo"><a href="#一个非常简单的-demo"]]>
    </summary>
    <title>通过命令行安装你的脚手架</title>
    <updated>2026-01-22T02:08:52.614Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="dynamic" scheme="https://qs12.cn/tags/dynamic/"/>
    <content>
      <![CDATA[<h2 id="vue和react中的组件动态加载"><a href="#vue和react中的组件动态加载" class="headerlink" title="vue和react中的组件动态加载"></a>vue和react中的组件动态加载</h2><h3 id="vue-的动态组件加载"><a href="#vue-的动态组件加载" class="headerlink" title="vue 的动态组件加载"></a>vue 的动态组件加载</h3><p><strong>首先说下需要注意的:</strong><br>动态记载需要加载的路径需要以静态的形式存在, 因为 <code>babel</code> 或者 <code>webpack</code> 解析的时候, 需要对这些资源文件进行预编译或者加载<br>举例说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Comp1</span> = (<span class="params"></span>)=&gt; <span class="keyword">import</span>(<span class="string">&#x27;@/views/demo/async/components/Comp1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NOT ok</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;@/views/demo/async/components/Comp1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Comp1</span> = (<span class="params"></span>)=&gt; <span class="keyword">import</span>(path)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NOT ok</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Comp1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">`@/views/demo/async/components/<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Comp1</span> = (<span class="params"></span>)=&gt; <span class="keyword">import</span>(path)</span><br></pre></td></tr></table></figure><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>通过传入加载的组件(import) 或者 动态的路径(require实现), 触发组件的 render, 从而动态加载组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 动态加载组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;AsyncLoadComp&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 可以传递动态加载组件的路径名称, 如果传递了, 那么 component 将不生效</span></span><br><span class="line">    <span class="attr">fullPath</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 也可以直接传递组件引用</span></span><br><span class="line">    <span class="attr">component</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Function</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">prop</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params">h</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> componentHandler = <span class="variable language_">this</span>.<span class="property">fullPath</span> ? <span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.fullPath&#125;</span>.vue`</span>) : <span class="variable language_">this</span>.<span class="property">component</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(componentHandler, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">prop</span>: <span class="variable language_">this</span>.<span class="property">prop</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要结合上边的配置文件一起传入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;button @click=&quot;load(&#x27;Comp1&#x27;)&quot;&gt;load1&lt;/button&gt;</span><br><span class="line">      &lt;button @click=&quot;load(&#x27;Comp2&#x27;)&quot;&gt;load2&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;async-load-comp :component=&quot;comp&quot;&gt;&lt;/async-load-comp&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import config from &#x27;./async-config&#x27;</span><br><span class="line">import AsyncLoadComp from &#x27;@/components/AsyncLoadComp&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        AsyncLoadComp</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            comp: ()=&gt;import(&#x27;@/views/async/components/Comp1&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    key() &#123;</span><br><span class="line">      return this.$route.path;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      load(key) &#123;</span><br><span class="line">          this.comp = config[key]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="vue-中的另一种类似的实现方式"><a href="#vue-中的另一种类似的实现方式" class="headerlink" title="vue 中的另一种类似的实现方式"></a>vue 中的另一种类似的实现方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-if</span>=<span class="string">&quot;dynamicComponent&quot;</span> <span class="attr">:is</span>=<span class="string">&quot;dynamicComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">dynamicComponent</span>: <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span> () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span>(<span class="string">&#x27;./lib-that-access-window-on-import&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">dynamicComponent</span> = <span class="variable language_">module</span>.<span class="property">default</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="react-的动态组件加载"><a href="#react-的动态组件加载" class="headerlink" title="react 的动态组件加载"></a>react 的动态组件加载</h3><p>道理是一个样子的, 需要将其作为一个 state 属性进行传递, 触发 render.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">asyncComponent</span>(<span class="params"><span class="attr">importComponent</span>: () =&gt; <span class="built_in">any</span></span>): <span class="title class_">React</span>.<span class="property">ComponentClass</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AsyncComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">            <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">                <span class="attr">component</span>: <span class="literal">null</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; <span class="attr">default</span>: component &#125; = <span class="keyword">await</span> <span class="title function_">importComponent</span>();</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">component</span>: component</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> C = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">component</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> C</span><br><span class="line">                ? <span class="language-xml"><span class="tag">&lt;<span class="name">C</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">                : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">AsyncComponent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="后记与总结"><a href="#后记与总结" class="headerlink" title="后记与总结"></a>后记与总结</h3><p>动态加载其实就是动态触发, 需要结合一个触发事件然后动态的加载需要的组件内容.</p><p>需要注意的是 webpack(babel) 中解析 <code>import</code> 的时候, 需要给定具体的路径.</p><p>具体的代码参照 <a href="https://github.com/qszy1210/slog/blob/master/codes/vue-multi/src/views/async/index.vue">github-vue-async</a></p>]]>
    </content>
    <id>https://qs12.cn/2020/12/30/vue%E5%92%8Creact%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/</id>
    <link href="https://qs12.cn/2020/12/30/vue%E5%92%8Creact%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    <published>2020-12-30T01:26:20.000Z</published>
    <summary>
      <![CDATA[<h2 id="vue和react中的组件动态加载"><a href="#vue和react中的组件动态加载" class="headerlink" title="vue和react中的组件动态加载"></a>vue和react中的组件动态加载</h2><h3 id="vue-的动态组件加载"><a href="#vue-的动态组件加载" class="headerlink" title="vue 的动态组件加载"></a>vue 的动态组件加载</h3><p><strong>首先说下需要注意的:</strong><br>动态记载需要加载的路径需要以静态的形式存在, 因为 <code>babel</code> 或者 <code>webpack</code> 解析的时候, 需要对这些资源文件进行预编译或者加载<br>举例说明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="l]]>
    </summary>
    <title>vue和react中的组件动态加载</title>
    <updated>2026-01-22T02:10:02.952Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="curry" scheme="https://qs12.cn/tags/curry/"/>
    <content>
      <![CDATA[<h2 id="curry-化的实现"><a href="#curry-化的实现" class="headerlink" title="curry 化的实现"></a>curry 化的实现</h2><p>一般的场景是这个样子, 必然有一个函数可以接受多个参数, 但是我们可以分多次调用传入</p><p>比如 <code>function sum(a, b, c) {return a+b+c}</code></p><p>调用时候实现方式如 <code>curryingSum(1)(2)(3)</code> 也可以实现调用,</p><p>需要提供一个 <code>currying</code> 函数, 将传入的方法进行处理.</p><p>核心使用原则是 <code>递归</code> 和 <code>方法的长度属性</code>. 不断将调用的参数传入, 并记录参数长度</p><p>recurs 和  fn.length</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">currying</span> = (<span class="params">fn, ...arg1</span>) =&gt; <span class="function">(<span class="params">...arg2</span>) =&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//主要是使用了 fn 中的 length 属性作为判断</span></span><br><span class="line">    <span class="keyword">return</span> [...arg2, ...arg1].<span class="property">length</span> === fn.<span class="property">length</span> ?</span><br><span class="line">    fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [...arg1, ...arg2]) :</span><br><span class="line">    <span class="comment">//注意这里的传入, 是采用解析的方式传入的, 与定义时候的声明是一致的.</span></span><br><span class="line">    <span class="comment">//如果定义的时候要接收数组, 那么这里也需要传入数组,</span></span><br><span class="line">    <span class="comment">//定义方式 (fn, ...arg1) 的形式, 即为分别参数的形式, 如果是 (fn, arg1), 代码中实际当做数组去使用的话, 那么这里就可以传数组</span></span><br><span class="line">    <span class="title function_">currying</span>(fn, ...arg1, ...arg2)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b,c</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abc is&#x27;</span>, a,b,c);</span><br><span class="line">    <span class="keyword">return</span> a+b+c&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="title function_">currying</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">c</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h2 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h2><ol><li>其中的 arg1, arg2 的顺序为什么这么去写</li><li>即, 形如 <code>c(1)(2)(3)</code> 我的实际调用顺序是 1&#x3D;&gt;2&#x3D;&gt;3 还是 3&#x3D;&gt;2&#x3D;&gt;1 呢, 又比如我增加括号 <code>((c(1))(2))(3)</code> 会有什么变化么?</li><li>通过 <code>fn.length</code> 去做属性判断, 那是否不定参数的就有问题了呢?</li></ol><p>回答:<br>前两个问题可以归结为调用顺序, 按照 js 优先级, 调用的顺序是<strong>从左到右</strong>依次进行的, 所以增加括号是一个含义,<br>先执行 <code>c(1)</code> 发现返回是一个函数, 才可以继续执行 <code>c(1)(2)</code>, 以后依次进行.<br>所以我们的调用顺序与声明顺序就是一致的.<br>比如以下测试函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sequence</span> = a=&gt;(<span class="variable language_">console</span>.<span class="title function_">log</span>(a), <span class="function"><span class="params">b</span>=&gt;</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(b), <span class="function"><span class="params">c</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(c)&#125;));</span><br><span class="line"><span class="title function_">sequence</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>第三个问题, 既然是不定参数, 此问题似乎也失去了意义, 原来的方法首先就支持不定参数的处理了.</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>重新回顾此问题, 是因为 redux 中到处 <code>curry</code> 的应用. 比如 <code>middleare</code> 的定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">aMiddleware</span> = store=&gt;<span class="function"><span class="params">next</span>=&gt;</span><span class="function"><span class="params">action</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//next 就是 dispatch</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用的地方</span></span><br><span class="line"><span class="title function_">applyMiddleware</span>(aMiddleware)</span><br><span class="line"><span class="comment">//内部调用逻辑</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 首先要给传入一个 store, 所以其中转化为数组的地方进行了调用</span></span><br><span class="line"><span class="comment"> * middlewares.map(m=&gt;m(store))</span></span><br><span class="line"><span class="comment"> * 2. 然后传入 dispatch, 通过 compose 进行从右到左实现嵌套调用</span></span><br><span class="line"><span class="comment"> * 3. 调用后, 返回值形如 action=&gt;&#123;....&#125;, 即 dispatch</span></span><br><span class="line"><span class="comment"> * 4. middleware 最终封装返回 store  &#123;...store, dispatch&#125;, 即将 dispatch 进行复写</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://qs12.cn/2020/08/05/%E4%BB%8Ecurry%E5%8C%96%E5%AE%9E%E7%8E%B0%E8%B0%88%E4%B8%80%E4%BA%9Bjs%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <link href="https://qs12.cn/2020/08/05/%E4%BB%8Ecurry%E5%8C%96%E5%AE%9E%E7%8E%B0%E8%B0%88%E4%B8%80%E4%BA%9Bjs%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <published>2020-08-05T13:28:15.000Z</published>
    <summary>
      <![CDATA[<h2 id="curry-化的实现"><a href="#curry-化的实现" class="headerlink" title="curry 化的实现"></a>curry 化的实现</h2><p>一般的场景是这个样子, 必然有一个函数可以接受多个参数, 但是我们可以分多次调用传入</p>
<p>比如 <code>function sum(a, b, c) {return a+b+c}</code></p>
<p>调用时候实现方式如 <code>curryingSum(1)(2)(3)</code> 也可以实现调用,</p>
<p>需要提供一个 <code>currying</code> 函数, 将传入的方法进行处理.</p>
<p>核心使用原则是 <code>递归</code> 和 <code>方法的长度属性</code>. 不断将调用的参数传入, 并记录参数长度</p>
<p>recurs 和  fn.length</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><s]]>
    </summary>
    <title>从curry化实现谈一些js中方法的实现</title>
    <updated>2026-01-22T02:08:34.225Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="code pattern" scheme="https://qs12.cn/tags/code-pattern/"/>
    <content>
      <![CDATA[<p>给自己布置这个题目在这里的时候, 我就知道不是一个好的题目. 并且这个也是一个持续的体会和总结.</p><p>当然, 对于一个好的代码的评判, 网上搜索可能一大推. 在多年coding后, 总结出来也会差不多.</p><p>基本上大方向的:</p><ol><li>可读性</li><li>可维护性</li><li>可扩展性</li></ol><p>从实际角度考虑的:</p><ol><li>逻辑清晰</li><li>运行效率高</li><li>问题(bug)少</li></ol><p>进一步的:</p><ol><li>算法上有调优处理 – 可能归结为效率问题</li><li>有模式上的实现  – 认为 模式是对逻辑清晰的一种命名, 将这个事情进行固化</li><li>模块之间的解耦 – 多人开发,沟通协作上有利, 也利于编码的可读性</li></ol><p>所以, 理解一下, 代码好坏与否, 在于两大块:</p><ol><li><strong>代码的沟通上</strong><br>代码作为程序的实现, 更作为程序员之间的语言, 是大家的一个工作”沟通”之地, 高效沟通是基础</li><li><strong>代码的实际运行上</strong><br><code>show me the code</code>, 代码的高效产出结果才是目的</li></ol><p>所以, 到这里我还没有达到我本来要说的事情, 具体这些还是原则上的东西.  所以, 有没有一些具体的东西呢?</p><p>我自己简单想了一下, 也争取做一个持续的总结整理, 这里只说一些具体的代码书写习惯以及风格上的东西</p><h3 id="多条件判断场景"><a href="#多条件判断场景" class="headerlink" title="多条件判断场景"></a>多条件判断场景</h3><p>上代码, 经常遇到很多个条件下的判断的问题, 存在多个符合条件下的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">whatYouWillSay</span>(<span class="params">role</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> conditionA = ...;</span><br><span class="line">    <span class="keyword">const</span> conditionB = ...;</span><br><span class="line">    <span class="keyword">const</span> conditionC = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conditionA &amp;&amp; conditionB &amp;&amp; conditionC) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的一个感觉就是非常不清晰, 别人读取这些条件判断的时候很不容易理解<br>我的一个感觉比好的体验是: 如果过分复杂,(将判断条件单独提出这个再说)</p><p>需要提取一些短路判断, 比如上边的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ...()&#123;</span><br><span class="line">    <span class="keyword">if</span> (!conditionA)&#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!conditionB) &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!conditionC) &#123;</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里的条件肯定都是满足的了, 上边的判断尽量简单明了, 让大家知道是什么意思</span></span><br><span class="line">    <span class="comment">//并且方法命名上也能自解释</span></span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要有默认值的返回"><a href="#要有默认值的返回" class="headerlink" title="要有默认值的返回"></a>要有默认值的返回</h3><p>对于一个方法, 首先要有一个判定, 我的输入和输出是什么, 然后再进行具体实现. 对于输出最好有一个默认值<br>所以 <code>typescript</code> 这里做得就比较好, 如果有声明输出, 没有显示输出的话, 经常会提示错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnStr</span>(<span class="params"></span>) : string &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我是一个 str</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;defaultStr&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写法上尽量少的创建一些中间变量"><a href="#写法上尽量少的创建一些中间变量" class="headerlink" title="写法上尽量少的创建一些中间变量"></a>写法上尽量少的创建一些中间变量</h3><p>但是如果中间变量可以让代码更清晰的话, 那就创建吧. 这里想到一个例子, 比如对数组需要做一个统计返回的处理<br><code>reducer</code> 都可以进行实现.</p><p>例如最普通的求和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>)=&gt;</span>sum+cur, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>例如要去遍历一个数组, 但是需要根据数组输出一个东西 (其实类似上边的求和, 复杂了一些)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> effectYourSomething = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">effect, item, index</span>)=&gt;</span>&#123;</span><br><span class="line">    effect[item] = index</span><br><span class="line">    <span class="keyword">return</span> effect;;</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">&#123;<span class="number">4</span>: <span class="number">0</span>, <span class="number">5</span>: <span class="number">1</span>, <span class="number">6</span>: <span class="number">2</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一种习惯或者素养, 并且是一个不断持续的过程.</p>]]>
    </content>
    <id>https://qs12.cn/2020/07/25/%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%BB%A3%E7%A0%81/</id>
    <link href="https://qs12.cn/2020/07/25/%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%BB%A3%E7%A0%81/"/>
    <published>2020-07-25T09:10:09.000Z</published>
    <summary>
      <![CDATA[<p>给自己布置这个题目在这里的时候, 我就知道不是一个好的题目. 并且这个也是一个持续的体会和总结.</p>
<p>当然, 对于一个好的代码的评判, 网上搜索可能一大推. 在多年coding后, 总结出来也会差不多.</p>
<p>基本上大方向的:</p>
<ol>
<li>可读性</li>
<li>可维护性</li>
<li>可扩展性</li>
</ol>
<p>从实际角度考虑的:</p>
<ol>
<li>逻辑清晰</li>
<li>运行效率高</li>
<li>问题(bug)少</li>
</ol>
<p>进一步的:</p>
<ol>
<li>算法上有调优处理 – 可能归结为效率问题</li>
<li>有模式上的实现  – 认为 模式是对逻辑清晰的一种命名, 将这个事情进行固化</li>
<li>模块之间的解耦 – 多人开发,沟通协作上有利, 也利于编码的可读性</li>
</ol>
<p>所以, 理解一下, 代码好坏与否, 在于两大块:</p>
<ol>
<li><strong>代码的沟通上</strong><br>代码作为程序的实现, 更作为程序员之间的语言, 是大家的一个工作”沟通”之地, 高效沟通是基础</li>
<li><strong>代码的实际运行上</strong><br><code>show me the code</code>, 代码的高效产出结果才是目的</li>
</ol>
<p>所以, 到这里我还没有达到我本来要说的事情, 具体这些还是原则上的东西.  所以, 有没有一些具体的东西呢?</p>
<p>我自己简单想了一下, 也争取做一个持续的总结整理, 这里只说一些具体的代码书写习惯以及风格上的东西</p>
<h3 id="多条件判断场景"><a href="#多条件判断场景" class="headerlink" title="多条件判断场景]]>
    </summary>
    <title>怎么才能写一个好代码</title>
    <updated>2026-01-22T02:09:47.584Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="yeoman" scheme="https://qs12.cn/tags/yeoman/"/>
    <content>
      <![CDATA[<p>在 gulp 时代, 就开始有使用 <a href="https://yeoman.io/">yeoman</a>, 感觉是一个特别方便的脚手架.</p><p>在使用 <code>angularjs</code> 的时候, 经常用这个脚手架生成一些小东西去学习</p><p>在有了 <code>create-react-app</code> 这个命令之后, 似乎很少开始接触 yeoman.</p><p>yeoman 上有一个比较完善的学习教程 <a href="https://yeoman.io/authoring/index.html">getStart</a></p><p>但是突然想到有没有 generator 的 generator ?</p><p>果然有. 操作命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install -g generator-generator # 安装generator</span><br><span class="line">mkdir bsqy &amp;&amp; cd $_ # 新建并进入文件夹</span><br><span class="line">yo generator #执行安装的generator, 输入一些自己的内容. 等待一些时间</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成按照你命令的名字, 比如 qs 的一文件夹  generator-qs</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入文件夹</span></span><br><span class="line">cd generator-qs</span><br><span class="line">npm link # 让 yo 可以发现你</span><br><span class="line">yo qs # 会创建一个 dummyfile.txt 文件...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要是看一下 目录下 <code>generator/app/index.js</code> 中的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="title function_">prompting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Have Yeoman greet the user.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="title function_">yosay</span>(<span class="string">`Welcome to the brilliant <span class="subst">$&#123;chalk.red(<span class="string">&#x27;generator-bsqy&#x27;</span>)&#125;</span> generator!`</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prompts = [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;confirm&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;someAnswer&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Would you like to enable this option?&#x27;</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">prompt</span>(prompts).<span class="title function_">then</span>(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// To access props later use this.props.someAnswer;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span> = props;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">writing</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fs</span>.<span class="title function_">copy</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">templatePath</span>(<span class="string">&#x27;dummyfile.txt&#x27;</span>),</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">destinationPath</span>(<span class="string">&#x27;dummyfile.txt&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">install</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">installDependencies</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中有 提醒, 有写入创建文件, 有安装要执行的过程, 可以说达到了一个良好代表的标准了 <code>自解释</code></p><p>总结: 了解 yeoman 的快速上手, 可以快速的创建一些自己需要的模板, 如果有必要的话.</p>]]>
    </content>
    <id>https://qs12.cn/2020/07/21/yeoman%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <link href="https://qs12.cn/2020/07/21/yeoman%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <published>2020-07-21T15:56:09.000Z</published>
    <summary>
      <![CDATA[<p>在 gulp 时代, 就开始有使用 <a href="https://yeoman.io/">yeoman</a>, 感觉是一个特别方便的脚手架.</p>
<p>在使用 <code>angularjs</code> 的时候, 经常用这个脚手架生成一些小东西去学习</p>
<p>在有了 <code>create-react-app</code> 这个命令之后, 似乎很少开始接触 yeoman.</p>
<p>yeoman 上有一个比较完善的学习教程 <a href="https://yeoman.io/authoring/index.html">getStart</a></p>
<p>但是突然想到有没有 generator 的 generator ?</p>
<p>果然有. 操作命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install -g]]>
    </summary>
    <title>yeoman编写自己的脚手架</title>
    <updated>2026-01-22T02:10:21.237Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="algorithm" scheme="https://qs12.cn/tags/algorithm/"/>
    <content>
      <![CDATA[<h2 id="有趣的算法"><a href="#有趣的算法" class="headerlink" title="有趣的算法"></a>有趣的算法</h2><blockquote><p>对算法一直很陌生, 以后也会很陌生, 因为我是程序员,而不是数学家或者算法工程师<br>可这阻止不了算法的有趣.</p></blockquote><p>先有了 快慢指针,让人眼前一亮, 而后这里的二分方法又让人 一个激动</p><p>二分的方法很简单, 上来就是去找你的 <code>一半</code> 去, 快速定位.</p><p>整理的复杂度也会跟 快速排序等方法有得一拼.</p><p>二分的关键, 是找到<code>中间</code> 的, 然后对中间的进行目标比较, 然后继续<code>中间</code>划分</p><p><strong>这个获取中间的场景随着头尾的变动, 所以也是变动的.</strong> 我们要跟随着使用的场景去修改头尾</p><p>比较经典的场景就是去寻找一个数的插入位置. 这里有一个数字, 这里有一个数字, 我需要快速的找到这个数字应该插入的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个数组是假定已经排好顺序的, 这样这个二分才有意义</span></span><br><span class="line"><span class="comment">//定义好左右位置</span></span><br><span class="line"><span class="comment">//const target = 3.5</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> l = arr.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>, <span class="comment">// 最左侧的位置</span></span><br><span class="line">    j = l - <span class="number">1</span>; <span class="comment">//最右侧的位置</span></span><br><span class="line"><span class="keyword">let</span> mid = i + <span class="title class_">Math</span>.<span class="title function_">floor</span>((j-i)/<span class="number">2</span>) <span class="comment">// 或者可以使用位移 (j-i)&gt;&gt;1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = l; <span class="comment">//暂定我们要返回的就是最后一个点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接选择中间的位置进行比较,</span></span><br><span class="line"></span><br><span class="line">arr[mid] &gt; target</span><br><span class="line"><span class="comment">//如果中间的位置的数值比目标大, 那么数值肯定在中间以左, 我们需要修改右侧的位置(相对的mid也会变动)</span></span><br><span class="line">j = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果相等, 那么正好, 我们要的目标就是这个地方</span></span><br><span class="line">ret = mid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理, 如果中间的位置小, 那么数字肯定在中间以右, 我们需要修改左侧的位置</span></span><br><span class="line">i = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//step2:</span></span><br><span class="line"><span class="comment">//因为正常情况下, 我们认为我们的元素是从小到大金星排列的, 所以正常的时候, 插入位置在右侧(&gt;=)</span></span><br><span class="line"><span class="comment">//所以上边的判断可以合并</span></span><br><span class="line"></span><br><span class="line">arr[mid] &gt;= target</span><br><span class="line">ret = mid</span><br><span class="line">j = mid -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每次修改后, 我们需要重新计算 `mid`, 所以我们将方法进行整理后 ,如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左侧索引小于右侧, i = j, 也可以, 代表我们的遍历还是有元素的</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = i + <span class="title class_">Math</span>.<span class="title function_">floor</span>((j-i)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt;= target) &#123;</span><br><span class="line">        ret = mid;</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        i = mid + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//step3: 我们整理成完整的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findPosition</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> l = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, <span class="comment">// 最左侧的位置</span></span><br><span class="line">    j = l - <span class="number">1</span>; <span class="comment">//最右侧的位置</span></span><br><span class="line">    <span class="keyword">let</span> ret = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = i + <span class="title class_">Math</span>.<span class="title function_">floor</span>((j-i)/<span class="number">2</span>);<span class="comment">//可以使用位移的方法, &gt;&gt;</span></span><br><span class="line">        <span class="keyword">let</span> mid = i + (j-i&gt;&gt;<span class="number">1</span>); <span class="comment">//注意运算符优先级 位移操作的优先级是小于 + - 的</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= target) &#123;</span><br><span class="line">            ret = mid;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://qs12.cn/2020/07/17/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86/</id>
    <link href="https://qs12.cn/2020/07/17/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BA%8C%E5%88%86/"/>
    <published>2020-07-17T08:06:31.000Z</published>
    <summary>
      <![CDATA[<h2 id="有趣的算法"><a href="#有趣的算法" class="headerlink" title="有趣的算法"></a>有趣的算法</h2><blockquote>
<p>对算法一直很陌生, 以后也会很陌生, 因为我是程序员,而不是数学家或者算法工程师<br>可这阻止不了算法的有趣.</p>
</blockquote>
<p>先有了 快慢指针,让人眼前一亮, 而后这里的二分方法又让人 一个激动</p>
<p>二分的方法很简单, 上来就是去找你的 <code>一半</code> 去, 快速定位.</p>
<p>整理的复杂度也会跟 快速排序等方法有得一拼.</p>
<p>二分的关键, 是找到<code>中间</code> 的, 然后对中间的进行目标比较, 然后继续<code>中间</code>划分</p>
<p><strong>这个获取中间的场景随着头尾的变动, 所以也是变动的.</strong> 我们要跟随着使用的场景去修改头尾</p>
<p>比较经典的场景就是去寻找一个数的插入位置. 这里有一个数字, 这里有一个数字, 我需要快速的找到这个数字应该插入的位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">]]>
    </summary>
    <title>有趣的二分</title>
    <updated>2025-07-11T06:34:18.216Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="javascript" scheme="https://qs12.cn/categories/javascript/"/>
    <category term="javascript reduce" scheme="https://qs12.cn/tags/javascript-reduce/"/>
    <content>
      <![CDATA[<h2 id="对于reduce的认识"><a href="#对于reduce的认识" class="headerlink" title="对于reduce的认识"></a>对于reduce的认识</h2><p>引子:<br>经常会用到 reducer, 并且80%以上的时候都会用于计算 加和. 所以, 在我的记忆模型中<br>reder 是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>)=&gt;</span>&#123;...&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第一个就是 sum 的内容, 所以我要做的一个事情, 自然就是要处理 sum, 所以 <code>...</code> 中的内容补全</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>)=&gt;</span>&#123;</span><br><span class="line">    sum = sum + cur</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>看起来仍然没有问题, 但是这里却隐藏着一个很大的误解, 就是根本不用执行赋值的这一步.<br>reduer 的作用就是 <strong>会将上一次的返回结果赋值到第一个参数中</strong>, 这个才是reduce 的强大作用<br>所以, 可以简单写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>)=&gt;</span>sum+cur, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>也可以传递引用:<br>用来执行连续的 promise, 由于 then 返回的仍然为 promise, 所以, 把当前的都放在 then 中进行处理.<br>处理结果会复制给下一次, 等下一次执行的时候, 直接再次执行 then. 实现顺序执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [promise1, promise2, ...];</span><br><span class="line"></span><br><span class="line">promises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">then</span>(<span class="function"><span class="params">d</span>=&gt;</span>cur)</span><br><span class="line">&#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>https://qs12.cn/2020/04/17/%E5%86%8D%E8%B0%88reduce/</id>
    <link href="https://qs12.cn/2020/04/17/%E5%86%8D%E8%B0%88reduce/"/>
    <published>2020-04-17T07:59:02.000Z</published>
    <summary>
      <![CDATA[<h2 id="对于reduce的认识"><a href="#对于reduce的认识" class="headerlink" title="对于reduce的认识"></a>对于reduce的认识</h2><p>引子:<br>经常会用到 reducer, 并且80%以上的时候都会用于计算 加和. 所以, 在我的记忆模型中<br>reder 是这样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>)=&gt;</span>&#123;...&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>第一个就是 sum 的内容, 所以我要做的一个事情, 自然就是要处理 sum, 所以 <code>...</code> 中的内容补全</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><s]]>
    </summary>
    <title>再谈reduce</title>
    <updated>2026-01-22T02:09:37.594Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="tools" scheme="https://qs12.cn/categories/tools/"/>
    <category term="keyboard" scheme="https://qs12.cn/tags/keyboard/"/>
    <category term="shortcut" scheme="https://qs12.cn/tags/shortcut/"/>
    <category term="效率" scheme="https://qs12.cn/tags/%E6%95%88%E7%8E%87/"/>
    <content>
      <![CDATA[<h2 id="键盘原则-左右原则-鼠标原则"><a href="#键盘原则-左右原则-鼠标原则" class="headerlink" title="键盘原则, 左右原则, 鼠标原则"></a>键盘原则, 左右原则, 鼠标原则</h2><h3 id="键盘原则"><a href="#键盘原则" class="headerlink" title="键盘原则"></a>键盘原则</h3><p>尽量使用键盘, 但有一个前提是使用键盘能快速得处理和解决问题, 如果使用键盘反而没有使用鼠标快, 那不值得.<br>所以将高频的一些内容使用快捷键将会是非常省力的行为.</p><h3 id="左右原则"><a href="#左右原则" class="headerlink" title="左右原则"></a>左右原则</h3><p>尽量将快捷键定义在左手区, 这样可以将右手尽量释放出来, 进行一些鼠标的处理. 毕竟鼠标的速度在大部分情况下是战胜键盘的</p><h3 id="鼠标原则"><a href="#鼠标原则" class="headerlink" title="鼠标原则"></a>鼠标原则</h3><p>对于一些不经常使用, 或者频率比较少的操作, 尽量使用鼠标 (如果是为了显示得高大上, 当我没说, 但技术不讲究面子上的东西)</p><h2 id="最少原则-尽量避免过度复杂"><a href="#最少原则-尽量避免过度复杂" class="headerlink" title="最少原则, 尽量避免过度复杂"></a>最少原则, 尽量避免过度复杂</h2><blockquote><p>否则将陷入一个无尽的循环, 比如说造船是为了出海, 结果船造好后, 为了将船的功能丰富, 而一直折腾, 结果耽误了出海.<br>这个是偏离了初心的.</p></blockquote><blockquote><p>所以尽量将快捷键固定化, 其他的一些细碎的能够使用鼠标的还是可以使用鼠标.<br>一定要 <em>高频</em> 的场景才值得使用快捷键.</p></blockquote>]]>
    </content>
    <id>https://qs12.cn/2019/10/18/2019-10-24-keyboard-%E5%8E%9F%E5%88%99/</id>
    <link href="https://qs12.cn/2019/10/18/2019-10-24-keyboard-%E5%8E%9F%E5%88%99/"/>
    <published>2019-10-18T07:25:26.000Z</published>
    <summary>
      <![CDATA[<h2 id="键盘原则-左右原则-鼠标原则"><a href="#键盘原则-左右原则-鼠标原则" class="headerlink" title="键盘原则, 左右原则, 鼠标原则"></a>键盘原则, 左右原则, 鼠标原则</h2><h3 id="键盘原则"><a href="#键盘原则" class="headerlink" title="键盘原则"></a>键盘原则</h3><p>尽量使用键盘, 但有一个前提是使用键盘能快速得处理和解决问题, 如果使用键盘反而没有使用鼠标快, 那不值得.<br>所以将高频的一些内容使用快捷键将会是非常省力的行为.</p>
<h3 id="左右原则"><a href="#左右原则" class="headerlink" title="左右原则"></a>左右原则</h3><p>尽量将快捷键定义在左手区, 这样可以将右手尽量释放出来, 进行一些鼠标的处理. 毕竟鼠标的速度在大部分情况下是战胜键盘的</p>
<h3 id="鼠标原则"><a href="#鼠标原则" class="headerlink" title="鼠标原则"></a>鼠标原则</h3><p>对于一些不经常使用, 或者频率比较少的操作, 尽量使用鼠标 (如果是为了显示得高大上, 当我没说, 但技术不讲究面子上的东西)</p>
<h2 id="最少原则-尽量避免过度复杂"><a href="#最少原则-尽量避免过度复杂" class="headerlink" title="最少原则, 尽量避免过度复杂"></a>最少原则, 尽量避免过度复杂</h2><blockquote>
<p>否则将陷入一个无尽的循环, 比如说造船是为了出海, 结果船造好后, 为了将船的功能丰富, 而一直折腾, 结果耽误了出海.<br>这个是偏离了初心的.</p>
</blockquote>
<bl]]>
    </summary>
    <title>2019-10-18-keyboard-原则</title>
    <updated>2025-07-11T06:34:18.217Z</updated>
  </entry>
  <entry>
    <author>
      <name>张青松</name>
    </author>
    <category term="life" scheme="https://qs12.cn/categories/life/"/>
    <category term="start" scheme="https://qs12.cn/tags/start/"/>
    <content>
      <![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>三十而立, 我三十才刚正式开始北京生活. 一直想弄个博客, 折腾了好久, 才算是真正的要去搭建<br>一个博客了. 这里作为一个开篇说明, 会把自己以前积累的一点点东西拿过来. 希望可以有一些生活的记录.</p>]]>
    </content>
    <id>https://qs12.cn/2018/07/15/2018-07-15-%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BC%80%E7%AF%87/</id>
    <link href="https://qs12.cn/2018/07/15/2018-07-15-%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BC%80%E7%AF%87/"/>
    <published>2018-07-14T17:47:34.000Z</published>
    <summary>
      <![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>三十而立, 我三十才刚正式开始北京生活. 一直想弄个博客, 折腾了好久, 才算是真正的要去搭建<br>一个博客了. 这里作为一个开篇说明, 会把自己以前积累的一点点东西拿过来. 希望可以有一些生活的记录.</p>]]>
    </summary>
    <title>博客的开篇</title>
    <updated>2025-07-11T06:34:18.217Z</updated>
  </entry>
</feed>
